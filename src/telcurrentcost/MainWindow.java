/*
 * Copyright (C) 2011 Michael Turner <michael at turnerendlesslearning.com>
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package telcurrentcost;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.text.DateFormatSymbols;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class MainWindow extends javax.swing.JFrame implements DataSentListener {

    public java.net.URL weatherUrl;
    public Weather weather;
    /** Creates new form MainWindow */
    public MainWindow() {
        initComponents();
        
        startWeatherThread();
        startSerialPort();        
    }
    private void startSerialPort() {
        Serial s = new Serial();
        try {
            s.connect("/dev/ttyUSB0", this);
        } catch (Exception ex) {
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    private void startWeatherThread() {
        weather = new Weather("http://www.weather.gov/xml/current_obs/KLXT.xml");
        Thread t = new Thread(weather);
        t.start();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jTextArea1.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new MainWindow().setVisible(true);

            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables

    public String getText() {
        return this.jTextArea1.getText();
    }

    public void setText(String s) {
        this.jTextArea1.setText(s);
    }

    public void dataReceived(DataSentEvent dse) {
        String usr = "";
        String watts = null;
        String time = null;
        String temp = null;


        String xml = dse.getData().trim();
         
        Document doc = null;
        try {
            doc = XMLParser.parseXml(xml);
            if (doc == null) {
                return;
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            return;
        }



        NodeList nl = doc.getElementsByTagName("watts");
        if (nl.getLength() > 0) {
            try {
                int w1 = Integer.parseInt(nl.item(0).getTextContent());
                int w2 = Integer.parseInt(nl.item(1).getTextContent());
                watts = String.valueOf(w1 + w2);
                usr += "Total Watts: " + watts + "\n";
            } catch (Exception ex) {
                Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);

            }
        }

        nl = doc.getElementsByTagName("time");
        if (nl.getLength() > 0) {
            time = nl.item(0).getTextContent();
            usr += "Time: " + time + "\n";
        }

        nl = doc.getElementsByTagName("tmprF");
        if (nl.getLength() > 0) {
            temp = nl.item(0).getTextContent();
            usr += "Temp: " + temp + "\n";
        }

        //update rrd
        if(time != null && watts != null) {

            //Get outside weather if available
            if(this.weather.isLoaded()) {
                temp = String.valueOf(this.weather.getTemp());
                usr += "Outside Temp: " + temp + "\n";
            }

            String updateStr = "N:" + watts + ":" + temp;
            LinuxCommand.run(updateStr);

            // Write to Text File
            File f = new File(System.getProperty("user.home") + "/currentcost/now.txt");
            try {
                BufferedWriter bw = new BufferedWriter(new FileWriter(f));
                bw.write(usr);
                bw.close();
            } catch (IOException ex) {
                Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        //Deal with history data
        nl = doc.getElementsByTagName("hist");
        if (nl.getLength() > 0) {
            parseHistData(doc, xml);
        }

        this.jTextArea1.setText(usr + "\n\n" + xml);

        
    }

    private void parseHistData(Document doc, String xml) {
        //Get Data Child NOdes
        NodeList dcn = doc.getElementsByTagName("data");
        if (dcn.getLength() > 0) {
            for (int i = 0; i < dcn.getLength(); i++) {
                if (dcn.item(i).hasChildNodes()) {
                    boolean foundSensorZero = false;
                    for (int j = 0; j < dcn.item(i).getChildNodes().getLength(); j++) {
                        Node baby = dcn.item(i).getChildNodes().item(j);
                        String nName = baby.getNodeName();
                        String nText = baby.getTextContent();
                        Calendar now = Calendar.getInstance();


                        if (nName.equalsIgnoreCase("Sensor") && nText.equalsIgnoreCase("0")) {
                            foundSensorZero = true;
                            continue;
                        } else if (nName.equalsIgnoreCase("Sensor") && !nText.equalsIgnoreCase("0")) {
                            continue;
                        } else if (foundSensorZero) {
                            System.out.println("Real Time: " + now.toString());

                            //Got Useful History data here:
                            float kilowatts = Float.valueOf(nText);

                            int thisYear = now.get(Calendar.YEAR);
                            int thisMonth = now.get(Calendar.MONTH);
                            int thisDate = now.get(Calendar.DATE);

                            //Get the time from the xml
                            NodeList timeNodes = doc.getElementsByTagName("time");
                            String dataDate = null;
                            int dataHour = 0;
                            int dataMinute = 0;
                            int dataSecond = 0;

                            if (timeNodes.getLength() > 0) {
                                dataDate = timeNodes.item(0).getTextContent();
                                dataHour = Integer.valueOf(dataDate.substring(0, dataDate.indexOf(":")));
                                dataMinute = Integer.valueOf(dataDate.substring((dataDate.indexOf(":") + 1), dataDate.lastIndexOf(":")));
                                dataSecond = Integer.valueOf(dataDate.substring((dataDate.lastIndexOf(":") + 1)));
                            }

                            now.set(thisYear, thisMonth, thisDate, dataHour, dataMinute, dataSecond);

                            int unitsAgo = 0;
                            String type = null;

                            String query = null;
                            if (nName.charAt(0) == 'h') {
                                type = "hour";
                                unitsAgo = Integer.valueOf(nName.trim().substring(1));
                                now.add(Calendar.HOUR, -(unitsAgo));
                                
                                String dbDate = String.valueOf(now.get(Calendar.YEAR));
                                dbDate += "-";
                                dbDate += String.valueOf(now.get(Calendar.MONTH) + 1);
                                dbDate += "-";
                                dbDate += String.valueOf(now.get(Calendar.DATE));
                                dbDate += " ";
                                dbDate += String.valueOf(now.get(Calendar.HOUR_OF_DAY));
                                dbDate += ":00:00";

                                //Check to see if it exists first
                                if(!recordExists("SELECT COUNT(*) AS count FROM hourly WHERE (starttime = '" + dbDate + "')")) {
                                    query = "INSERT INTO hourly (starttime, kilowatts) VALUES ('" + dbDate + "', " + Float.valueOf(kilowatts)
                                            + ")";
                                    insertQuery(query);
                                }
                            } else if (nName.charAt(0) == 'd') {
                                System.out.println(xml);
                                type = "day";
                                unitsAgo = Integer.valueOf(nName.trim().substring(1));
                                if(dataHour >= 23) {
                                    now.add(Calendar.HOUR, 2);
                                }
                                now.add(Calendar.DATE, -(unitsAgo));

                                String dbDate = String.valueOf(now.get(Calendar.YEAR));
                                dbDate += "-";
                                dbDate += String.valueOf(now.get(Calendar.MONTH) + 1);
                                dbDate += "-";
                                dbDate += String.valueOf(now.get(Calendar.DATE));

                                System.out.println(String.valueOf(unitsAgo) + " day(s) ago");
                                if(!recordExists("SELECT COUNT(*) AS count FROM daily WHERE (day = '" + dbDate + "')")) {
                                    query = "INSERT INTO daily (day, kilowatts) VALUES ('" + dbDate + "', " + Float.valueOf(kilowatts)
                                            + ")";
                                    insertQuery(query);
                                }
                               
                            } else if (nName.charAt(0) == 'm') {
                                type = "month";
                                now.add(Calendar.MONTH, -(unitsAgo));
                                unitsAgo = Integer.valueOf(nName.trim().substring(1));

                                if (!recordExists("SELECT COUNT(*) AS count FROM monthly WHERE (month=" + String.valueOf(now.get(Calendar.MONTH) + 1) + ")")) {
                                    query = "INSERT INTO monthly (month, kilowatts) VALUES ("
                                            + String.valueOf(now.get(Calendar.MONTH) + 1) + ", "
                                            + String.valueOf(kilowatts) + ")";
                                    insertQuery(query);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    private boolean recordExists(String query) {
        System.out.println("COUNTING QUERY: " + query);
        ResultSet rs = executeQuery(query);
        
        boolean retVal = false;

        try {
            if(rs.next()) {
                System.out.println("COUNT: " + String.valueOf(rs.getInt("count")));
                if(rs.getInt("count") > 0) {
                    retVal = true;
                } else {
                    retVal = false;
                }
            }
        } catch (SQLException ex) {
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
        }

        if(retVal) {
            System.out.println("DUP");
        } else
            System.out.println("NOT FOUND");
        return retVal;
    }
    private ResultSet executeQuery(String query) {

        Statement stmt;
        String url = "jdbc:mysql://localhost:3306/currentcost";
        Connection con;
        try {
            con = DriverManager.getConnection(url, "currentcost", "ODUpcv98hkjnfaSfh");
            stmt = con.createStatement();
            ResultSet rs = stmt.executeQuery(query);
            return rs;
        } catch (SQLException ex) {
            System.out.println(query);
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
    private void insertQuery(String query) {
        Statement stmt;
        String url = "jdbc:mysql://localhost:3306/currentcost";
        Connection con;
        try {
            con = DriverManager.getConnection(url, "currentcost", "ODUpcv98hkjnfaSfh");
            stmt = con.createStatement();
            stmt.execute(query);
            System.out.println(query);
        } catch (SQLException ex) {
            System.out.println(query);
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private String getMonthForInt(int m) {
        String month = "invalid";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (m >= 0 && m <= 11) {
            month = months[m];
        }
        return month;
    }

    private String getDayForInt(int m) {
        String day = "invalid";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] days = dfs.getWeekdays();
        if (m >= 0 && m <= 11) {
            day = days[m];
        }
        return day;
    }
}
